import SignPDF from './SignPDF.min.cjs';
import fs from 'node:fs';
import axios from 'axios';
import FormData from 'form-data';
import plainplaceholder from './customSignPdf/plainplaceholder.min.js';
import { plainAddPlaceholder } from 'node-signpdf/dist/helpers/index.js';
const serverUrl = process.env.SERVER_URL,
  APPID = process.env.APP_ID,
  masterKEY = process.env.MASTER_KEY;
async function uploadFile(a) {
  try {
    var e = new FormData(),
      t =
        (e.append('file', fs.createReadStream(a)),
        { 'content-type': 'multipart/form-data', 'X-Parse-Application-Id': process.env.APP_ID }),
      s = process.env.SERVER_URL.slice(0, -4) + '/file_upload';
    return (await axios.post(s, e, { headers: t })).data;
  } catch (e) {
    console.log('err ', e), fs.unlinkSync(a);
  }
}
async function updateDoc(t, s, r, i, o, n) {
  try {
    var d = {
      UserPtr: { __type: 'Pointer', className: n, objectId: r },
      SignedUrl: s,
      Activity: 'Signed',
      ipAddress: i,
    };
    let e;
    var l = (e = o.AuditTrail && 0 < o.AuditTrail.length ? [...o.AuditTrail, d] : [d]).filter(
      e => 'Signed' === e.Activity
    );
    let a = !1;
    !((o.Signers && 0 < o.Signers.length && l.length !== o.Signers.length) || !(a = !0));
    var p = { SignedUrl: s, AuditTrail: e, IsCompleted: a };
    await axios.put(serverUrl + '/classes/contracts_Document/' + t, p, {
      headers: {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': APPID,
        'X-Parse-Master-Key': masterKEY,
      },
    });
    return { isCompleted: a, message: 'success' };
  } catch (e) {
    return console.log('update doc err ', e), 'err';
  }
}
async function sendMail(e) {
  var a = e.url,
    t = e.sender,
    s = e.pdfName,
    a = {
      url: a,
      from: 'OpenSign™',
      recipient: e.receiver,
      subject: 'You have signed the doc - ' + s,
      pdfName: s,
      html:
        "<html><head><meta http-equiv='Content-Type' content='text/html; charset=UTF-8' /></head><body>  <div style='background-color:#f5f5f5;padding:20px'>    <div style='box-shadow: rgba(0, 0, 0, 0.1) 0px 4px 12px;background-color:white;'> <div><img src=https://qikinnovation.ams3.digitaloceanspaces.com/logo.png  height='50' style='padding:20px'/> </div><div style='padding:2px;font-family:system-ui; background-color: #47a3ad;'>    <p style='font-size:20px;font-weight:400;color:white;padding-left:20px',>  Document Copy</p></div><div><p style='padding:20px;font-family:system-ui;font-size:14px'>A copy of the document " +
        s +
        ' Standard is attached to this email. Kindly download the document from the attachment.</p></div> </div><div><p>This is an automated email from Open Sign. For any queries regarding this email, please contact the sender ' +
        t.Mail +
        ' directly. If you think this email is inappropriate or spam, you may file a complaint with Open Sign here.</p></div></div></body></html>',
    };
  await axios.post(serverUrl + '/functions/sendmailv3', a, {
    headers: {
      'Content-Type': 'application/json',
      'X-Parse-Application-Id': APPID,
      'X-Parse-Master-Key': masterKEY,
    },
  });
}
async function sendCompletedMail(e) {
  var a = e.url,
    t = e.sender,
    s = e.pdfName,
    a = {
      url: a,
      from: 'OpenSign™',
      recipient: e.receiver,
      subject: `Document ${s} has beeen signed by all parties`,
      pdfName: s,
      html:
        "<html><head><meta http-equiv='Content-Type' content='text/html; charset=UTF-8' /></head><body>  <div style='background-color:#f5f5f5;padding:20px'>    <div style='box-shadow: rgba(0, 0, 0, 0.1) 0px 4px 12px;background-color:white;'> <div><img src=https://qikinnovation.ams3.digitaloceanspaces.com/logo.png  height='50' style='padding:20px'/> </div><div style='padding:2px;font-family:system-ui; background-color: #47a3ad;'>    <p style='font-size:20px;font-weight:400;color:white;padding-left:20px',> Document sign successfully</p></div><div><p style='padding:20px;font-family:system-ui;font-size:14px'>All parties have successfully signed the document" +
        s +
        '. Kindly download the document from the attachment.</p></div> </div><div><p>This is an automated email from Open Sign. For any queries regarding this email, please contact the sender ' +
        t.Mail +
        ' directly. If you think this email is inappropriate or spam, you may file a complaint with Open Sign here.</p></div></div></body></html>',
    };
  await axios.post(serverUrl + '/functions/sendmailv3', a, {
    headers: {
      'Content-Type': 'application/json',
      'X-Parse-Application-Id': APPID,
      'X-Parse-Master-Key': masterKEY,
    },
  });
}
async function PDF(s, r) {
  try {
    var i = s.params.sign,
      e = s.params.docId,
      o = s.params.userId,
      n = await axios.get(serverUrl + '/classes/contracts_Document/' + e + '?include=ExtUserPtr', {
        headers: {
          'Content-Type': 'application/json',
          'X-Parse-Application-Id': APPID,
          'X-Parse-Master-Key': masterKEY,
        },
      }),
      d = await axios.get(serverUrl + '/users/me', {
        headers: {
          'X-Parse-Application-Id': APPID,
          'X-Parse-Session-Token': s.headers.sessiontoken,
        },
      });
    if (!d.data || !d.data.objectId) return { status: 'error', message: 'this user not allowed!' };
    {
      var l,
        p,
        c,
        m = JSON.stringify({ objectId: o });
      let a, t;
      t = o
        ? (l = await axios.get(serverUrl + '/classes/contracts_Contactbook?where=' + m, {
            headers: {
              'X-Parse-Application-Id': APPID,
              'X-Parse-Session-Token': s.headers.sessiontoken,
            },
          })).data && 0 < l.data.results.length
          ? ((a = l), 'contracts_Contactbook')
          : ((a = await axios.get(serverUrl + '/classes/contracts_Users?where=' + m, {
              headers: {
                'X-Parse-Application-Id': APPID,
                'X-Parse-Master-Key': masterKEY,
              },
            })),
            'contracts_Users')
        : ((p = JSON.stringify({
            UserId: { __type: 'Pointer', className: '_User', objectId: d.data.objectId },
          })),
          (c = await axios.get(serverUrl + '/classes/contracts_Users?where=' + p, {
            headers: {
              'X-Parse-Application-Id': APPID,
              'X-Parse-Master-Key': masterKEY,
            },
          })).data && 0 < c.data.results.length
            ? ((a = c), 'contracts_Users')
            : ((a = await axios.get(serverUrl + '/classes/contracts_Contactbook?where=' + p, {
                headers: {
                  'X-Parse-Application-Id': APPID,
                  'X-Parse-Session-Token': s.headers.sessiontoken,
                },
              })),
              'contracts_Contactbook'));
      var g = a.data.results[0].Name,
        h = a.data.results[0].Email;
      if (!s.params.pdfFile) return { status: 'error', message: 'pdf file not present!' };
      {
        let e = Buffer.from(s.params.pdfFile, 'base64');
        var u = process.env.PFX_BASE64,
          f = Buffer.from(u, 'base64');
        e = i
          ? plainplaceholder({
              pdfBuffer: e,
              reason: 'Digitally signed by Open sign for ' + g + ' <' + h + '>',
              location: 'test location',
              signatureLength: 1e4,
              sign: i,
            })
          : plainAddPlaceholder({
              pdfBuffer: e,
              reason: 'Digitally signed by Open sign for ' + g + ' <' + h + '>',
              location: 'test location',
              signatureLength: 1e4,
            });
        var y = await new SignPDF(e, f).signPDF(),
          v = `./exports/exported_file_${Math.floor(5e3 * Math.random())}.pdf`,
          P = (fs.writeFileSync(v, y), await uploadFile(v));
        if (P && P.imageUrl) {
          const r = await updateDoc(
            s.params.docId,
            P.imageUrl,
            a.data.results[0].objectId,
            s.headers['x-real-ip'],
            n.data,
            t
          );
          return (
            sendMail({
              url: P.imageUrl,
              sender: { Mail: n.data.ExtUserPtr.Email, Name: n.data.ExtUserPtr.Name },
              pdfName: n.data.Name,
              receiver: h,
            }),
            r &&
              r.isCompleted &&
              sendCompletedMail({
                url: P.imageUrl,
                sender: { Mail: n.data.ExtUserPtr.Email, Name: 'Open sign' },
                pdfName: n.data.Name,
                receiver: n.data.ExtUserPtr.Email,
              }),
            fs.unlinkSync(v),
            console.log('New Signed PDF created called: ' + v),
            'success' === r.message
              ? { status: 'success', data: P.imageUrl }
              : { status: 'error', message: 'please provide required parameters!' }
          );
        }
      }
    }
  } catch (e) {
    return (
      console.log('Err ', e),
      'ERR_BAD_REQUEST' === e.code
        ? { status: 'error', message: 'Invalid session token!' }
        : { status: 'error', message: 'Encrypted files are currently not supported!' }
    );
  }
}
export default PDF;
